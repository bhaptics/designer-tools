{"version":3,"sources":["Interfaces.ts","MainApp.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["FeedbackType","mapping","mirrorVest","effect","dotFeedback","dotMode","feedback","map","f","pointList","p","index","pathFeedback","pathMode","x","parseFloat","toFixed","useState","files","suffix","state","setState","type","multiple","accept","onChange","e","target","size","length","count","i","file","fileReader","FileReader","onloadend","content","result","tactFile","JSON","parse","fileType","project","layout","name","Unknown","Vest","startsWith","Arm","Hand","Foot","converted","tracks","track","newT","effects","keys","Object","modes","tmp1","tmp2","push","fileName","stringify","readAsText","className","value","onClick","a","zip","JSZip","forEach","m","replace","generateAsync","ars","File","saveAs","App","MainApp","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.64dbdd2f.chunk.js","sourcesContent":["export enum FeedbackType {\r\n  Vest= 'Vest',\r\n  Arm = 'Arm',\r\n  Foot = 'Foot',\r\n  Hand = 'Hand',\r\n  Head = 'Head',\r\n  Unknown = 'Unknown'\r\n}\r\n\r\nexport interface TactFile {\r\n  fileName: string;\r\n  type: FeedbackType;\r\n  content: string;\r\n}\r\n","import React, { useState } from \"react\";\r\nimport { saveAs } from 'file-saver';\r\nimport JSZip from 'jszip';\r\nimport { FeedbackType, TactFile } from './Interfaces';\r\n\r\ntype State = {\r\n  files: TactFile[];\r\n  suffix: string;\r\n}\r\n\r\nconst mapping = [\r\n  3, 2, 1, 0,\r\n  7, 6, 5, 4,\r\n  11, 10, 9, 8,\r\n  15, 14, 13, 12,\r\n  19, 18, 17, 16,\r\n];\r\n\r\nconst mirrorVestIndex = (index: number) => {\r\n  return mapping[index];\r\n};\r\n\r\nconst mirrorVest = (effect: any) => {\r\n  const dotFeedback = effect.dotMode.feedback.map((f: any) => {\r\n      if (!f.pointList) {\r\n        return f;\r\n      }\r\n      return ({\r\n        ...f,\r\n        pointList: f.pointList.map((p: any) => {\r\n          return {\r\n            ...p,\r\n            index: mirrorVestIndex(p.index),\r\n          };\r\n        })\r\n      })\r\n  });\r\n\r\n  const pathFeedback = effect.pathMode.feedback.map((f: any) => {\r\n    return {\r\n      ...f,\r\n      pointList: f.pointList.map((p: any) => {\r\n        return {\r\n          ...p,\r\n          x: (1 - parseFloat(p.x)).toFixed(3),\r\n        };\r\n      })\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...effect,\r\n    dotMode: {\r\n      ...effect.dotMode,\r\n      feedback: dotFeedback,\r\n    },\r\n    pathMode: {\r\n      ...effect.pathMode,\r\n      feedback: pathFeedback,\r\n    }\r\n  }\r\n};\r\n\r\nexport default () => {\r\n  const[state, setState] = useState<State>({\r\n    files: [],\r\n    suffix: '_Mirror',\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <input\r\n          type={'file'}\r\n          multiple={true}\r\n          accept=\".tact\"\r\n          onChange={(e) => {\r\n            if (!e.target.files) {\r\n              return;\r\n            }\r\n\r\n            const files: TactFile[] = [];\r\n\r\n            const size = e.target.files.length;\r\n            let count = 0;\r\n            for (let i = 0; i < size; i++) {\r\n              const file = e.target.files[i];\r\n              const fileReader = new FileReader();\r\n              fileReader.onloadend = (e) => {\r\n                const content = fileReader.result;\r\n                count++;\r\n                if (typeof content !== 'string') {\r\n                  return;\r\n                }\r\n\r\n                let tactFile = JSON.parse(content);\r\n\r\n                let fileType = tactFile.project.layout.name;\r\n                let type = FeedbackType.Unknown;\r\n                if (fileType === 'Vest' || fileType === 'Tactot') {\r\n                  type = FeedbackType.Vest;\r\n                } else if (fileType.startsWith('Tactosy')) {\r\n                  type = FeedbackType.Arm;\r\n                } else if (fileType.startsWith('Hand')) {\r\n                  type = FeedbackType.Hand;\r\n                } else if (fileType.startsWith('Foot')) {\r\n                  type = FeedbackType.Foot;\r\n                }\r\n\r\n                const converted = {\r\n                  ...tactFile,\r\n                  project: {\r\n                    ...tactFile.project,\r\n                    tracks: tactFile.project.tracks.map((track: any) => {\r\n\r\n                      let newT = {\r\n                        ...track,\r\n                        effects: track.effects.map((effect: any) => {\r\n\r\n                          const keys = Object.keys(effect.modes);\r\n                          let tmp1 = keys[0];\r\n                          let tmp2 = keys[1];\r\n                          if (type === FeedbackType.Foot || type === FeedbackType.Hand || type === FeedbackType.Arm) {\r\n\r\n                            return ({\r\n                              ...effect,\r\n                              modes: {\r\n                                [tmp1]: effect.modes[tmp2],\r\n                                [tmp2]: effect.modes[tmp1],\r\n                              }\r\n                            })\r\n                          } else if(type === FeedbackType.Vest) {\r\n                            return ({\r\n                              ...effect,\r\n                              modes: {\r\n                                [tmp1]: mirrorVest(effect.modes[tmp1]),\r\n                                [tmp2]: mirrorVest(effect.modes[tmp2]),\r\n                              }\r\n                            })\r\n                          }\r\n\r\n\r\n                          return ({...effect})\r\n                        })\r\n                      };\r\n\r\n                      return {\r\n                        ...newT\r\n                      };\r\n                    })\r\n                  }\r\n                };\r\n\r\n\r\n                files.push({\r\n                  fileName: file.name,\r\n                  type,\r\n                  content: JSON.stringify(converted),\r\n                });\r\n\r\n\r\n                if (count === size) {\r\n                  setState({...state, files});\r\n                }\r\n              };\r\n              fileReader.readAsText(file);\r\n            }\r\n\r\n          }}\r\n        />\r\n\r\n        <label>Suffix : </label>\r\n        <input\r\n          className={'border rounded'}\r\n          value={state.suffix}\r\n          onChange={e => {\r\n            setState({...state, suffix: e.target.value});\r\n          }}\r\n          type={'text'} />\r\n\r\n        <button\r\n          className={'border rounded mx-2 px-4 py-2 bg-blue-500'}\r\n          onClick={async () => {\r\n            if (state.files.length === 0) {\r\n              return;\r\n            }\r\n\r\n            const zip = new JSZip();\r\n            state.files.forEach(m => {\r\n              zip.file(m.fileName.replace(\".tact\", \"\") + state.suffix + \".tact\", m.content);\r\n            });\r\n            const ars = await zip.generateAsync({type : \"blob\"});\r\n            const file = new File([ars], 'Mirror.zip', {type: \"application/zip;charset=utf-8\"});\r\n            saveAs(file);\r\n          }}>\r\n          Download converted files\r\n        </button>\r\n      </div>\r\n\r\n      <div>\r\n        {state.files.map((f => {\r\n          return (\r\n            <div key={f.fileName} className={'my-2 border-b rounded'}>\r\n              <div>\r\n                {f.fileName}\r\n                <label className={'mx-2'}>\r\n                  {f.type}\r\n                </label>\r\n              </div>\r\n            </div>\r\n          )\r\n        }))}\r\n        <div></div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","import React  from 'react';\nimport MainApp from './MainApp';\n\n\nfunction App() {\n  return (\n    <div className={'mx-auto max-w-screen-xl h-screen bg-gray-100'}>\n      <div className={'text-2xl mx-4 py-2'}>\n        Convert Tool\n      </div>\n\n      <MainApp/>\n\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}